import os, sys

from optparse import OptionParser
from time import sleep


def runshell(*args):
    print "shell:" + " ".join(args)
    print os.spawnlp(os.P_WAIT, args[0], *args)


p = OptionParser()
p.add_option("-i", "--input", dest="input", help="input file name")
p.add_option("-o", "--output", dest="output", help="output image name")
p.add_option("-m", "--map", dest="mapfile", help="name of mapping file to read")
p.add_option(
    "-c",
    "--nocenter",
    dest="doCenter",
    action="store_false",
    default=True,
    help="Do not recenter the sample",
)
p.add_option(
    "",
    "--incol",
    dest="incol",
    default="LACUNA_NUMBER",
    help="column to read from the map file and use as the input (raw image)",
)
p.add_option(
    "",
    "--outcol",
    dest="outcol",
    default="CHAIN",
    help="column to read from the map file and use as the output (image)",
)
p.add_option(
    "",
    "--outasfact",
    dest="outasfact",
    default=False,
    help="read output column as factor",
)
p.add_option(
    "",
    "--outmin",
    dest="outmin",
    default=1,
    help="minimum value for mapping colors to output",
)
p.add_option(
    "",
    "--outmax",
    dest="outmax",
    default=1000,
    help="maximum value for mapping colors to output",
)
p.add_option(
    "",
    "--outrescale",
    dest="outRescale",
    action="store_true",
    default=False,
    help="Rescale output values to min and max in map",
)

p.add_option(
    "-r",
    "--notrfile",
    dest="rFile",
    default=True,
    action="store_false",
    help="Is the input file generated by R",
)
p.add_option(
    "",
    "--filter",
    dest="filtText",
    default="CHAIN_LENGTH,LT,5:SAMPLE,EQ,1",
    help="Filter as : seperated statements with , seperated terms",
)
(options, args) = p.parse_args()
print options
if options.rFile:
    headerFunc = lambda x: x.upper()[1:-1]
else:
    headerFunc = lambda x: x.upper()
# Read in the map file
filtList = options.filtText.split(":")
sleep(1)
with open(options.mapfile, "r") as mapfile:
    headerLine = mapfile.readline()
    header = map(headerFunc, headerLine.split(","))
    hDict = dict(map(lambda x: (x[1], x[0]), enumerate(header)))

    def tryFalse(func, *x):
        try:
            return func(*x)
        except:
            print (x, " is malformed")
            return False

    def tryWrap(func):
        return lambda *x: tryFalse(func, *x)

    def filtToFunc(iFilt, eVal=0.1):
        print "filtfunc"
        cFilt = iFilt.split(",")
        print (iFilt, cFilt)
        cCol = hDict[cFilt[0]]
        cVal = float(cFilt[2])
        if cFilt[1] == "GT":
            return tryWrap(lambda x: float(x[cCol]) > cVal)
        if cFilt[1] == "LT":
            return tryWrap(lambda x: float(x[cCol]) < cVal)
        if cFilt[1] == "EQ":
            return tryWrap(lambda x: abs(float(x[cCol]) - cVal) < eVal)

    sleep(1)
    filtFunc = map(filtToFunc, filtList)
    ckFiltFunc = lambda x: sum(map(lambda y: y(x), filtFunc)) == len(filtFunc)
    subdata = filter(
        lambda x: ckFiltFunc(x), map(lambda x: x.split(","), mapfile.readlines())
    )

inCol = hDict[options.incol]
outCol = hDict[options.outcol]
ioMap = dict(map(tryWrap(lambda x: (int(x[inCol]), float(x[outCol]))), subdata))
if len(ioMap) < 1:
    print "Nothing to do here!"
    exit()
keepBG = 1
if keepBG:
    bgVal = min(ioMap.values()) - 1
    ioMap[0] = bgVal
aimMapping = ",".join([str(a) + ":" + str(b) for (a, b) in ioMap.items()])
tiplBasedMapping = True
if tiplBasedMapping:
    iKeys = sorted(ioMap.values())
    ioMap = dict([(c, c) for c in iKeys])
iKeys = sorted(ioMap.keys())

kMin = iKeys[0]
kMax = iKeys[-1]
if options.outRescale:
    vMin = min(ioMap.values())
    vMax = max(ioMap.values())
else:
    vMin = float(options.outmin)
    vMax = float(options.outmax)
# color map
emptyVox = lambda k: [k, 0, 0, 0]
scaMap = lambda c: [1 - c, c, 2 * abs(0.5 - c)]
colMap = lambda v: scaMap((v - vMin) / (vMax - vMin + 1))
colVox = lambda k, v: [k] + colMap(v)

# visibility map
invisVox = lambda k: [k, 0, 0.5, 0] + [k + 0.5, 0, 0.5, 0]
visVox = lambda k: [k, 1, 0.5, 0]
hvisVox = lambda k: [k, 0.02, 0.5, 0]

mapTable = emptyVox(kMin - 1)
# mapTable=[]
alpTable = invisVox(kMin - 1)
for iVal in range(kMin, kMax + 1):
    if keepBG & iVal == bgVal:
        mapTable += [iVal, 1, 1, 0]
        alpTable += hvisVox(iVal)
    elif ioMap.has_key(iVal):
        mapTable += colVox(iVal, ioMap[iVal])
        alpTable += visVox(iVal)
    else:
        # mapTable+=emptyVox(iVal)
        alpTable += invisVox(iVal)
mapTable += emptyVox(kMax + 1)
alpTable += invisVox(kMax + 1)

print ("Rendering from ", vMin, "->", vMax)
# Start Reading Files
doCenter = options.doCenter
tiffile = options.input
outfile = options.output

objname = tiffile.split("/")[0]
filename = tiffile.split("/")[-1]
# java and tipl libraries
jcmd = "/afs/psi.ch/project/tipl/jvm/bin/java"
tiplpath = "/afs/psi.ch/project/tipl/jar/TIPL_beta.jar"
jargs = "-d64 -Xmx12G -Xms10G"
imgfile = "/home/scratch/mader/" + outfile + ".tif"
rawfile = "/home/scratch/mader/" + outfile + ".raw"

runshell("cp", tiffile, imgfile)
runshell(
    jcmd,
    "-cp",
    tiplpath,
    "-Xmx12G",
    "-Xms10G",
    "tipl.formats.MappedImage",
    "-convert=" + imgfile,
    "-output=" + rawfile,
    "-mapping=" + aimMapping,
    "-defaultval=0",
)


from paraview.simple import *
from paraview import vtk
from paraview import servermanager as sm

filename = rawfile
headername = filename + "-raw.dat"
header = open(headername).readlines()

dim = [int(cEle) for cEle in header[0].split(",")]
imageType = int(header[1])
print " Loading " + filename + " size:" + str(dim)
imgIn = ImageReader()
print imgIn.ListProperties()
if doCenter:
    dx = int(dim[0] / 2)
    dy = int(dim[1] / 2)
    dz = int(dim[2] / 2)
    # imgIn.DataExtent=[1-dx,dim[0]-dx,1-dy,dim[1]-dy,1-dz,dim[2]-dz]
    # print imgIn.DataExtent
    imgIn.DataOrigin = [-dx, -dy, -dz]


imgIn.DataExtent = [1, dim[0], 1, dim[1], 1, dim[2]]

minVal = 0
maxVal = 127
if imageType == 0:
    imgIn.DataScalarType = "unsigned char"
if imageType == 1:
    imgIn.DataScalarType = "short"
    maxVal = 1000
if imageType == 2:
    imgIn.DataScalarType = "int"
    maxVal = 1000
if imageType == 3:
    imgIn.DataScalarType = "float"
    minVal = 0
    maxVal = 1


imgIn.FilePrefix = filename


def VolumeColoring(objRep, UseLogScale=False):
    sof = CreatePiecewiseFunction()
    sof.Points = alpTable  # [vMin,0,0.5,0,vMax,1,0.5,0]
    lut = sm.rendering.PVLookupTable()
    lut.RGBPoints = mapTable
    lut.VectorMode = 0
    lut.ScalarRangeInitialized = 1
    lut.UseLogScale = UseLogScale
    objRep.ScalarOpacityFunction = sof
    # lut.IndexedLookup=1
    oldCount = lut.NumberOfTableValues
    lut.NumberOfTableValues = kMax - kMin + 2
    print ("curcountvals", oldCount, "->", lut.NumberOfTableValues)
    # lut.Annotations=anTable
    objRep.LookupTable = lut
    objRep.ColorArrayName = imgIn.ScalarArrayName
    objRep.Representation = "Volume"
    # objRep.VolumeRenderingMode = 'Ray Cast and Texture Mapping'
    objRep.InterpolateScalarsBeforeMapping = 0
    ScalarBarWidgetRepresentation1 = CreateScalarBar(
        Title="SAF",
        Enabled=1,
        LabelFontSize=12,
        LabelColor=[0.0, 0.0, 1.0],
        TitleFontSize=12,
        TitleColor=[0.0, 0.0, 1.0],
    )
    ScalarBarWidgetRepresentation1.LookupTable = lut
    return ScalarBarWidgetRepresentation1


objRep = Show()
scaleBar = VolumeColoring(objRep)


RenderView1 = GetRenderView()


RenderView = GetRenderView()  # set camera properties for current view
RenderView.CameraViewUp = [-0.25, 0.82, -0.51]
RenderView.CameraViewUp = [-0.59, 0.08, 0.79]
RenderView.CameraViewUp = [-0.2, -0.2, 0.99]  # (Birds Eye Over Z)
RenderView.CameraViewUp = [0, 0.0, 1]
RenderView.CameraFocalPoint = [0.5, 0.5, 0.5]
RenderView.CameraClippingRange = [2.91, 9.55]
RenderView.CameraPosition = [1.85, 3.79, 4.40]
RenderView.ViewSize = [1024, 1024]

GetRenderView().Representations.append(scaleBar)


Render()
print RenderView.CameraPosition
WriteImage(outfile + ".png")
sm.SaveState(outfile + ".pvsm")
print (RenderView.CameraPosition)
# RenderView.WriteImage('/Users/maderk/test3.png',"vtkPNGWriter",1)
